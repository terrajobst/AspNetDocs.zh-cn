---
uid: mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
title: ASP.NET MVC 和网页中的 XSRF/CSRF 防护 |Microsoft Docs
author: Rick-Anderson
description: 跨站点请求伪造（也称为 XSRF 或 CSRF）是一种针对 web 托管应用程序的攻击，恶意网站可能会影响 interacti 。
ms.author: riande
ms.date: 03/14/2013
ms.assetid: aadc5fa4-8215-4fc7-afd5-bcd2ef879728
msc.legacyurl: /mvc/overview/security/xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages
msc.type: authoredcontent
ms.openlocfilehash: fb7e76101cbe6a874ddf5b3429ca2dc6d474334b
ms.sourcegitcommit: 22fbd8863672c4ad6693b8388ad5c8e753fb41a2
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 11/28/2019
ms.locfileid: "74595765"
---
# <a name="xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages"></a><span data-ttu-id="b6f68-103">ASP.NET MVC 和网页中的 XSRF/CSRF 防护</span><span class="sxs-lookup"><span data-stu-id="b6f68-103">XSRF/CSRF Prevention in ASP.NET MVC and Web Pages</span></span>

<span data-ttu-id="b6f68-104">作者： [Rick Anderson]((https://twitter.com/RickAndMSFT))</span><span class="sxs-lookup"><span data-stu-id="b6f68-104">by [Rick Anderson]((https://twitter.com/RickAndMSFT))</span></span>

> <span data-ttu-id="b6f68-105">跨站点请求伪造（也称为 XSRF 或 CSRF）是一种针对 Web 托管型应用程序的攻击，恶意网站凭此可以影响客户端浏览器与受该浏览器信任的网站之间的交互。</span><span class="sxs-lookup"><span data-stu-id="b6f68-105">Cross-site request forgery (also known as XSRF or CSRF) is an attack against web-hosted applications whereby a malicious web site can influence the interaction between a client browser and a web site trusted by that browser.</span></span> <span data-ttu-id="b6f68-106">这些攻击出现的原因可能是 Web 浏览器针对每一个对网站的请求自动发送身份验证令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-106">These attacks are made possible because web browsers will send authentication tokens automatically with every request to a web site.</span></span> <span data-ttu-id="b6f68-107">典型示例是身份验证 cookie，如 ASP.NET 的表单身份验证票证。</span><span class="sxs-lookup"><span data-stu-id="b6f68-107">The canonical example is an authentication cookie, such as ASP.NET's Forms Authentication ticket.</span></span> <span data-ttu-id="b6f68-108">然而，使用任何持久身份验证（如 Windows Authentication、Basic 等）的网站也可能成为受攻击目标。</span><span class="sxs-lookup"><span data-stu-id="b6f68-108">However, web sites which use any persistent authentication mechanism (such as Windows Authentication, Basic, and so forth) can be targeted by these attacks.</span></span>
> 
> <span data-ttu-id="b6f68-109">XSRF 攻击不同于网络钓鱼攻击。</span><span class="sxs-lookup"><span data-stu-id="b6f68-109">An XSRF attack is distinct from a phishing attack.</span></span> <span data-ttu-id="b6f68-110">网络钓鱼攻击需要与受害者进行交互。</span><span class="sxs-lookup"><span data-stu-id="b6f68-110">Phishing attacks require interaction from the victim.</span></span> <span data-ttu-id="b6f68-111">在网络钓鱼攻击中，恶意网站将仿冒目标网站，受到欺骗的受害者会向攻击者提供敏感信息。</span><span class="sxs-lookup"><span data-stu-id="b6f68-111">In a phishing attack, a malicious web site will mimic the target web site, and the victim is fooled into providing sensitive information to the attacker.</span></span> <span data-ttu-id="b6f68-112">在 XSRF 攻击中，通常不必与受害者进行交互。</span><span class="sxs-lookup"><span data-stu-id="b6f68-112">In an XSRF attack, there is often no interaction necessary from the victim.</span></span> <span data-ttu-id="b6f68-113">相反，浏览器自动向目标网站发送所有相关 cookie 为攻击者提供了可乘之机。</span><span class="sxs-lookup"><span data-stu-id="b6f68-113">Rather, the attacker is relying on the browser automatically sending all relevant cookies to the destination web site.</span></span>
> 
> <span data-ttu-id="b6f68-114">有关详细信息，请参阅[打开 Web 应用程序安全项目](https://www.owasp.org/index.php/Main_Page)（OWASP） [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))。</span><span class="sxs-lookup"><span data-stu-id="b6f68-114">For more information, see the [Open Web Application Security Project](https://www.owasp.org/index.php/Main_Page)(OWASP) [XSRF](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).</span></span>

## <a name="anatomy-of-an-attack"></a><span data-ttu-id="b6f68-115">攻击剖析</span><span class="sxs-lookup"><span data-stu-id="b6f68-115">Anatomy of an attack</span></span>

<span data-ttu-id="b6f68-116">若要演练 XSRF 攻击，请考虑要执行一些在线银行交易的用户。</span><span class="sxs-lookup"><span data-stu-id="b6f68-116">To walk through an XSRF attack, consider a user who wants to perform some online banking transactions.</span></span> <span data-ttu-id="b6f68-117">此用户先访问 WoodgroveBank.com 并登录，此时响应标头将包含她的身份验证 cookie：</span><span class="sxs-lookup"><span data-stu-id="b6f68-117">This user first visits WoodgroveBank.com and logs in, at which point the response header will contain her authentication cookie:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample1.cmd)]

<span data-ttu-id="b6f68-118">因为身份验证 cookie 是会话 cookie，浏览器在浏览器进程退出时会自动将其清除。</span><span class="sxs-lookup"><span data-stu-id="b6f68-118">Because the authentication cookie is a session cookie, it will be automatically cleared by the browser when the browser process exits.</span></span> <span data-ttu-id="b6f68-119">但在此之前，浏览器将自动在每个请求中包括 cookie 和 WoodgroveBank.com。</span><span class="sxs-lookup"><span data-stu-id="b6f68-119">However, until that time, the browser will automatically include the cookie with each request to WoodgroveBank.com.</span></span> <span data-ttu-id="b6f68-120">用户现在想要将 $1000 传输到另一个帐户，因此她在银行站点上填写表单，浏览器向服务器发出此请求：</span><span class="sxs-lookup"><span data-stu-id="b6f68-120">The user now wants to transfer $1000 to another account, so she fills out a form on the banking site, and the browser makes this request to the server:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample2.cmd)]

<span data-ttu-id="b6f68-121">由于此操作有副作用（它启动了一个货币事务），因此银行站点已选择要求 HTTP POST 以便启动此操作。</span><span class="sxs-lookup"><span data-stu-id="b6f68-121">Because this operation has a side effect (it initiates a monetary transaction), the banking site has chosen to require an HTTP POST in order to initiate this operation.</span></span> <span data-ttu-id="b6f68-122">服务器从请求中读取身份验证令牌，查找当前用户的帐号，验证是否存在足够的资金，然后启动该事务进入目标帐户。</span><span class="sxs-lookup"><span data-stu-id="b6f68-122">The server reads the authentication token from the request, looks up the current user's account number, verifies that sufficient funds exist, and then initiates the transaction into the destination account.</span></span>

<span data-ttu-id="b6f68-123">她的在线银行完成后，用户离开银行网站并访问 web 上的其他位置。</span><span class="sxs-lookup"><span data-stu-id="b6f68-123">Her online banking complete, the user navigates away from the banking site and visits other locations on the web.</span></span> <span data-ttu-id="b6f68-124">其中一个站点– fabrikam.com –在嵌入到 &lt;iframe&gt;的页面上包含以下标记：</span><span class="sxs-lookup"><span data-stu-id="b6f68-124">One of those sites – fabrikam.com – includes the following markup on a page embedded within an &lt;iframe&gt;:</span></span>

[!code-html[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample3.html)]

<span data-ttu-id="b6f68-125">然后，它将导致浏览器发出此请求：</span><span class="sxs-lookup"><span data-stu-id="b6f68-125">Which then causes the browser to make this request:</span></span>

[!code-console[Main](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/samples/sample4.cmd)]

<span data-ttu-id="b6f68-126">攻击者利用这一事实，用户可能仍具有适用于目标网站的有效身份验证令牌，而她使用 Javascript 的小片段来使浏览器自动向目标站点发出 HTTP POST。</span><span class="sxs-lookup"><span data-stu-id="b6f68-126">The attacker is exploiting the fact that the user might still have a valid authentication token for the target web site, and she is using a small snippet of Javascript to cause the browser to make an HTTP POST to the target site automatically.</span></span> <span data-ttu-id="b6f68-127">如果身份验证令牌仍然有效，银行站点将启动 $250 到攻击者选择的帐户的传输。</span><span class="sxs-lookup"><span data-stu-id="b6f68-127">If the authentication token is still valid, the banking site will initiate a transfer of $250 into the account of the attacker's choosing.</span></span>

### <a name="ineffective-mitigations"></a><span data-ttu-id="b6f68-128">低效缓解</span><span class="sxs-lookup"><span data-stu-id="b6f68-128">Ineffective mitigations</span></span>

<span data-ttu-id="b6f68-129">请注意，在上面的方案中，WoodgroveBank.com 是通过 SSL 访问的，并且只有仅限 SSL 的身份验证 cookie，才能阻止攻击。</span><span class="sxs-lookup"><span data-stu-id="b6f68-129">It is interesting to note that in the above scenario, the fact that WoodgroveBank.com was being accessed via SSL and had an SSL-only authentication cookie was insufficient to thwart the attack.</span></span> <span data-ttu-id="b6f68-130">攻击者可以在其 &lt;窗体&gt; 元素中指定[URI 方案](http://en.wikipedia.org/wiki/URI_scheme)（https），浏览器将继续将未过期的 cookie 发送到目标站点，前提是这些 cookie 与目标站点的 uri 方案一致。</span><span class="sxs-lookup"><span data-stu-id="b6f68-130">The attacker is able to specify the [URI scheme](http://en.wikipedia.org/wiki/URI_scheme) (https) in her &lt;form&gt; element, and the browser will continue to send unexpired cookies to the target site as long as those cookies are consistent with the URI scheme of the intended target.</span></span>

<span data-ttu-id="b6f68-131">用户可能会认为，用户只应不访问不受信任的站点，因为仅访问可信网站有助于保持联机安全。</span><span class="sxs-lookup"><span data-stu-id="b6f68-131">One could argue that the user should simply not visit untrusted sites, as visiting only trusted sites is helps to remain safe online.</span></span> <span data-ttu-id="b6f68-132">这一点很有意义，但遗憾的是，这一建议并不总是可行。</span><span class="sxs-lookup"><span data-stu-id="b6f68-132">There is some truth to this, but unfortunately this advice is not always practical.</span></span> <span data-ttu-id="b6f68-133">用户可能 "信任" 本地新闻站点 ConsolidatedMessenger。</span><span class="sxs-lookup"><span data-stu-id="b6f68-133">Perhaps the user "trusts" the local news site ConsolidatedMessenger.</span></span> <span data-ttu-id="b6f68-134">ConsolidatedMessenger.com 和转而转而改为访问该站点，但该站点的 XSS 漏洞允许攻击者插入在 fabrikam.com 上运行的相同代码片段。</span><span class="sxs-lookup"><span data-stu-id="b6f68-134">ConsolidatedMessenger.com and goes to visit that site instead, but that site has an XSS vulnerability which allows an attacker to inject the same snippet of code that was running on fabrikam.com.</span></span>

<span data-ttu-id="b6f68-135">可以验证传入请求是否具有引用域的[Referer 标头](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)。</span><span class="sxs-lookup"><span data-stu-id="b6f68-135">You can verify that incoming requests have a [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) referencing your domain.</span></span> <span data-ttu-id="b6f68-136">这将停止从第三方域中无意提交的请求。</span><span class="sxs-lookup"><span data-stu-id="b6f68-136">This will stop requests unwittingly submitted from a third-party domain.</span></span> <span data-ttu-id="b6f68-137">但有些人出于隐私原因禁用了其浏览器的 Referer 标头，如果受害者安装了某些不安全的软件，攻击者有时会欺骗该标头。</span><span class="sxs-lookup"><span data-stu-id="b6f68-137">However, some people disable their browser's Referer header for privacy reasons, and attackers can sometimes spoof that header if the victim has certain insecure software installed.</span></span> <span data-ttu-id="b6f68-138">验证[Referer 标头](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14)不会被视为阻止 XSRF 攻击的安全方法。</span><span class="sxs-lookup"><span data-stu-id="b6f68-138">Verifying the [Referer header](http://www.w3.org/Protocols/HTTP/HTRQ_Headers.html#z14) is not considered a secure approach to preventing XSRF attacks.</span></span>

## <a name="web-stack-runtime-xsrf-mitigations"></a><span data-ttu-id="b6f68-139">Web Stack 运行时 XSRF 缓解</span><span class="sxs-lookup"><span data-stu-id="b6f68-139">Web Stack Runtime XSRF mitigations</span></span>

<span data-ttu-id="b6f68-140">ASP.NET Web Stack 运行时使用[同步器令牌模式](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern)的变体来防御 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="b6f68-140">The ASP.NET Web Stack Runtime uses a variant of the [synchronizer token pattern](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern) to defend against XSRF attacks.</span></span> <span data-ttu-id="b6f68-141">同步令牌模式的一般形式是将两个 XSRF 令牌提交给服务器，每个 HTTP POST （除了身份验证令牌）：一个令牌作为 cookie，另一个用作表单值。</span><span class="sxs-lookup"><span data-stu-id="b6f68-141">The general form of the synchronizer token pattern is that two anti-XSRF tokens are submitted to the server with each HTTP POST (In addition to the authentication token): one token as a cookie, and the other as a form value.</span></span> <span data-ttu-id="b6f68-142">ASP.NET 运行时生成的令牌值不是由攻击者确定的，也不是可预测的。</span><span class="sxs-lookup"><span data-stu-id="b6f68-142">The token values generated by the ASP.NET runtime are not deterministic or predictable by an attacker.</span></span> <span data-ttu-id="b6f68-143">提交令牌后，服务器将仅在两个令牌通过比较检查时才允许请求继续。</span><span class="sxs-lookup"><span data-stu-id="b6f68-143">When the tokens are submitted, the server will allow the request to proceed only if both tokens pass a comparison check.</span></span>

<span data-ttu-id="b6f68-144">XSRF 请求验证*会话令牌*存储为 HTTP cookie，当前在其负载中包含以下信息：</span><span class="sxs-lookup"><span data-stu-id="b6f68-144">The XSRF request verification *session token* is stored as an HTTP cookie and currently contains the following information in its payload:</span></span>

- <span data-ttu-id="b6f68-145">安全令牌，由随机的128位标识符组成。</span><span class="sxs-lookup"><span data-stu-id="b6f68-145">A security token, consisting of a random 128-bit identifier.</span></span>   
 <span data-ttu-id="b6f68-146">下图显示了使用 Internet Explorer F12 开发人员工具显示的 XSRF 请求验证会话令牌：（请注意，这是当前的实现，甚至可能会发生更改。）</span><span class="sxs-lookup"><span data-stu-id="b6f68-146">The following image shows the XSRF request verification session token displayed with the Internet Explorer F12 developer tools: (Note this is the current implementation and is subject, even likely, to change.)</span></span>

![](xsrfcsrf-prevention-in-aspnet-mvc-and-web-pages/_static/image1.png)

<span data-ttu-id="b6f68-147">*字段标记*存储为 `<input type="hidden" />`，并在其负载中包含以下信息：</span><span class="sxs-lookup"><span data-stu-id="b6f68-147">The *field token* is stored as an `<input type="hidden" />` and contains the following information in its payload:</span></span>

- <span data-ttu-id="b6f68-148">已登录用户的用户名（如果已经过身份验证）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-148">The logged-in user's username (if authenticated).</span></span>
- <span data-ttu-id="b6f68-149">[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)提供的任何其他数据。</span><span class="sxs-lookup"><span data-stu-id="b6f68-149">Any additional data provided by an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx).</span></span>

<span data-ttu-id="b6f68-150">防 XSRF 令牌的负载经过加密和签名，因此使用工具检查令牌时，无法查看用户名。</span><span class="sxs-lookup"><span data-stu-id="b6f68-150">The payloads of the anti-XSRF tokens are encrypted and signed, so you can't view the username when using tools to examine the tokens.</span></span> <span data-ttu-id="b6f68-151">如果 web 应用程序面向 ASP.NET 4.0，则[MachineKey](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx)例程会提供加密服务。</span><span class="sxs-lookup"><span data-stu-id="b6f68-151">When the web application is targeting ASP.NET 4.0, cryptographic services are provided by the [MachineKey.Encode](https://msdn.microsoft.com/library/system.web.security.machinekey.encode.aspx) routine.</span></span> <span data-ttu-id="b6f68-152">当 web 应用程序面向 ASP.NET 4.5 或更高版本时，会通过[MachineKey](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110))例程提供加密服务，从而提供更好的性能、扩展性和安全性。</span><span class="sxs-lookup"><span data-stu-id="b6f68-152">When the web application is targeting ASP.NET 4.5 or higher, cryptographic services are provided by the [MachineKey.Protect](https://msdn.microsoft.com/library/system.web.security.machinekey.protect(v=vs.110)) routine, which offers better performance, extensibility, and security.</span></span> <span data-ttu-id="b6f68-153">有关更多详细信息，请参阅以下博客文章：</span><span class="sxs-lookup"><span data-stu-id="b6f68-153">See the following blog posts for more details:</span></span>

- [<span data-ttu-id="b6f68-154">ASP.NET 4.5，pt 中的加密改进</span><span class="sxs-lookup"><span data-stu-id="b6f68-154">Cryptographic Improvements in ASP.NET 4.5, pt. 1</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/22/cryptographic-improvements-in-asp-net-4-5-pt-1.aspx)
- [<span data-ttu-id="b6f68-155">ASP.NET 4.5，pt 中的加密改进</span><span class="sxs-lookup"><span data-stu-id="b6f68-155">Cryptographic Improvements in ASP.NET 4.5, pt. 2</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/23/cryptographic-improvements-in-asp-net-4-5-pt-2.aspx)
- [<span data-ttu-id="b6f68-156">ASP.NET 4.5，pt 中的加密改进</span><span class="sxs-lookup"><span data-stu-id="b6f68-156">Cryptographic Improvements in ASP.NET 4.5, pt. 3</span></span>](https://blogs.msdn.com/b/webdev/archive/2012/10/24/cryptographic-improvements-in-asp-net-4-5-pt-3.aspx)

## <a name="generating-the-tokens"></a><span data-ttu-id="b6f68-157">生成令牌</span><span class="sxs-lookup"><span data-stu-id="b6f68-157">Generating the tokens</span></span>

<span data-ttu-id="b6f68-158">若要生成 XSRF 标记，请从 Razor 页面调用[@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx)方法，或从 Razor 页面调用 @AntiForgery.GetHtml（）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-158">To generate the anti-XSRF tokens, call the [@Html.AntiForgeryToken](https://msdn.microsoft.com/library/dd470175.aspx) method from an MVC view or @AntiForgery.GetHtml() from a Razor page.</span></span> <span data-ttu-id="b6f68-159">运行时将执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="b6f68-159">The runtime will then perform the following steps:</span></span>

1. <span data-ttu-id="b6f68-160">如果当前 HTTP 请求已经包含 XSRF 会话令牌（\_RequestVerificationToken 的反 XSRF cookie \_），则会从该令牌中提取安全令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-160">If the current HTTP request already contains an anti-XSRF session token (the anti-XSRF cookie \_\_RequestVerificationToken), the security token is extracted from it.</span></span> <span data-ttu-id="b6f68-161">如果 HTTP 请求不包含 XSRF 会话令牌，或如果提取安全令牌失败，将生成一个新的随机反 XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-161">If the HTTP request does not contain an anti-XSRF session token or if extraction of the security token fails, a new random anti-XSRF token will be generated.</span></span>
2. <span data-ttu-id="b6f68-162">使用上述步骤（1）中的安全令牌和当前已登录用户的标识生成 XSRF 字段令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-162">An anti-XSRF field token is generated using the security token from step (1) above and the identity of the current logged-in user.</span></span> <span data-ttu-id="b6f68-163">（有关确定用户标识的详细信息，请参阅下面的 " **[具有特殊支持的方案](#_Scenarios_with_special)** " 部分。）此外，如果配置了[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) ，则运行时将调用其[GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx)方法，并将返回的字符串包含在字段标记中。</span><span class="sxs-lookup"><span data-stu-id="b6f68-163">(For more information on determining user identity, see the **[Scenarios with special support](#_Scenarios_with_special)** section below.) Additionally, if an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/jj158328(v=vs.111).aspx) is configured, the runtime will call its [GetAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.getadditionaldata(v=vs.111).aspx) method and include the returned string in the field token.</span></span> <span data-ttu-id="b6f68-164">（有关详细信息，请参阅 **[配置和扩展性](#_Configuration_and_extensibility)** 部分。）</span><span class="sxs-lookup"><span data-stu-id="b6f68-164">(See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.)</span></span>
3. <span data-ttu-id="b6f68-165">如果在步骤（1）中生成了新的 XSRF 令牌，则将创建一个新的会话令牌来包含该令牌，并将其添加到出站 HTTP cookie 集合中。</span><span class="sxs-lookup"><span data-stu-id="b6f68-165">If a new anti-XSRF token was generated in step (1), a new session token will be created to contain it and will be added to the outbound HTTP cookies collection.</span></span> <span data-ttu-id="b6f68-166">步骤（2）中的字段标记将包装在 `<input type="hidden" />` 元素中，此 HTML 标记将是 `Html.AntiForgeryToken()` 或 `AntiForgery.GetHtml()`的返回值。</span><span class="sxs-lookup"><span data-stu-id="b6f68-166">The field token from step (2) will be wrapped in an `<input type="hidden" />` element, and this HTML markup will be the return value of `Html.AntiForgeryToken()` or `AntiForgery.GetHtml()`.</span></span>

## <a name="validating-the-tokens"></a><span data-ttu-id="b6f68-167">验证令牌</span><span class="sxs-lookup"><span data-stu-id="b6f68-167">Validating the tokens</span></span>

<span data-ttu-id="b6f68-168">若要验证传入的 XSRF 令牌，开发人员需要在其 MVC 操作或控制器上包含一个[ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx)属性，或从她的 Razor 页面调用 `@AntiForgery.Validate()`。</span><span class="sxs-lookup"><span data-stu-id="b6f68-168">To validate the incoming anti-XSRF tokens, the developer includes a [ValidateAntiForgeryToken](https://msdn.microsoft.com/library/system.web.mvc.validateantiforgerytokenattribute(VS.108).aspx) attribute on her MVC action or controller, or she calls `@AntiForgery.Validate()` from her Razor page.</span></span> <span data-ttu-id="b6f68-169">运行时将执行以下步骤：</span><span class="sxs-lookup"><span data-stu-id="b6f68-169">The runtime will perform the following steps:</span></span>

1. <span data-ttu-id="b6f68-170">读取传入会话令牌和字段令牌，并从每个会话中提取 XSRF 标记。</span><span class="sxs-lookup"><span data-stu-id="b6f68-170">The incoming session token and field token are read and the anti-XSRF token extracted from each.</span></span> <span data-ttu-id="b6f68-171">生成例程中的每个步骤（2）都必须具有相同的 XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-171">The anti-XSRF tokens must be identical per step (2) in the generation routine.</span></span>
2. <span data-ttu-id="b6f68-172">如果对当前用户进行身份验证，则会将她的用户名与存储在字段令牌中的用户名进行比较。</span><span class="sxs-lookup"><span data-stu-id="b6f68-172">If the current user is authenticated, her username is compared with the username stored in the field token.</span></span> <span data-ttu-id="b6f68-173">用户名必须匹配。</span><span class="sxs-lookup"><span data-stu-id="b6f68-173">The usernames must match.</span></span>
3. <span data-ttu-id="b6f68-174">如果配置了[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) ，则运行时将调用其*ValidateAdditionalData*方法。</span><span class="sxs-lookup"><span data-stu-id="b6f68-174">If an [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) is configured, the runtime calls its *ValidateAdditionalData* method.</span></span> <span data-ttu-id="b6f68-175">方法必须返回布尔值*true*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-175">The method must return the Boolean value *true*.</span></span>

<span data-ttu-id="b6f68-176">如果验证成功，则允许请求继续。</span><span class="sxs-lookup"><span data-stu-id="b6f68-176">If validation succeeds, the request is allowed to proceed.</span></span> <span data-ttu-id="b6f68-177">如果验证失败，框架将引发*HttpAntiForgeryException*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-177">If validation fails, the framework will throw an *HttpAntiForgeryException*.</span></span>

## <a name="failure-conditions"></a><span data-ttu-id="b6f68-178">失败条件</span><span class="sxs-lookup"><span data-stu-id="b6f68-178">Failure conditions</span></span>

<span data-ttu-id="b6f68-179">从 ASP.NET Web Stack 运行时 v2 开始，验证期间引发的任何*HttpAntiForgeryException*都将包含有关错误的详细信息。</span><span class="sxs-lookup"><span data-stu-id="b6f68-179">Starting with The ASP.NET Web Stack Runtime v2, any *HttpAntiForgeryException* that is thrown during validation will contain detailed information about what went wrong.</span></span> <span data-ttu-id="b6f68-180">当前定义的故障条件如下：</span><span class="sxs-lookup"><span data-stu-id="b6f68-180">The currently defined failure conditions are:</span></span>

- <span data-ttu-id="b6f68-181">请求中不存在会话令牌或窗体令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-181">The session token or form token is not present in the request.</span></span>
- <span data-ttu-id="b6f68-182">无法读取会话令牌或窗体令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-182">The session token or form token is unreadable.</span></span> <span data-ttu-id="b6f68-183">此问题最可能的原因是运行不匹配版本的 ASP.NET Web Stack 运行时或在场，其中 Web.config 中 &lt;machineKey&gt; 元素不同于计算机。</span><span class="sxs-lookup"><span data-stu-id="b6f68-183">The most likely cause of this is a farm running mismatched versions of The ASP.NET Web Stack Runtime or a farm where the &lt;machineKey&gt; element in Web.config differs between machines.</span></span> <span data-ttu-id="b6f68-184">可以使用 Fiddler 之类的工具通过篡改反 XSRF 标记来强制此异常。</span><span class="sxs-lookup"><span data-stu-id="b6f68-184">You can use a tool such as Fiddler to force this exception by tampering with either anti-XSRF token.</span></span>
- <span data-ttu-id="b6f68-185">已交换会话令牌和字段令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-185">The session token and field token were swapped.</span></span>
- <span data-ttu-id="b6f68-186">会话令牌和字段令牌包含不匹配的安全令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-186">The session token and field token contain mismatched security tokens.</span></span>
- <span data-ttu-id="b6f68-187">嵌入在字段令牌中的用户名与当前已登录用户的用户名不匹配。</span><span class="sxs-lookup"><span data-stu-id="b6f68-187">The username embedded within the field token does not match the current logged-in user's username.</span></span>
- <span data-ttu-id="b6f68-188">*[IAntiForgeryAdditionalDataProvider. ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* 方法返回*false*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-188">The *[IAntiForgeryAdditionalDataProvider.ValidateAdditionalData](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider.validateadditionaldata(v=vs.111).aspx)* method returned *false*.</span></span>

<span data-ttu-id="b6f68-189">XSRF 设施还可以在令牌生成或验证过程中执行额外检查，这些检查过程中的故障可能会导致引发异常。</span><span class="sxs-lookup"><span data-stu-id="b6f68-189">The anti-XSRF facilities may also perform additional checking during token generation or validation, and failures during these checks may result in exceptions being thrown.</span></span> <span data-ttu-id="b6f68-190">有关详细信息，请参阅[WIF/ACS/基于声明的身份验证](#_WIF_ACS)和 **[配置和扩展性](#_Configuration_and_extensibility)** 部分。</span><span class="sxs-lookup"><span data-stu-id="b6f68-190">See the [WIF / ACS / claims-based authentication](#_WIF_ACS) and **[Configuration and extensibility](#_Configuration_and_extensibility)** sections for more information.</span></span>

<a id="_Scenarios_with_special"></a>

## <a name="scenarios-with-special-support"></a><span data-ttu-id="b6f68-191">具有特殊支持的方案</span><span class="sxs-lookup"><span data-stu-id="b6f68-191">Scenarios with special support</span></span>

### <a name="anonymous-authentication"></a><span data-ttu-id="b6f68-192">匿名身份验证</span><span class="sxs-lookup"><span data-stu-id="b6f68-192">Anonymous authentication</span></span>

<span data-ttu-id="b6f68-193">反 XSRF 系统包含对匿名用户的特殊支持，其中 "anonymous" 被定义为用户，其中*IIdentity. IsAuthenticated*属性返回*false*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-193">The anti-XSRF system contains special support for anonymous users, where "anonymous" is defined as a user where the *IIdentity.IsAuthenticated* property returns *false*.</span></span> <span data-ttu-id="b6f68-194">方案包括向登录页提供 XSRF 保护（在对用户进行身份验证之前）和自定义身份验证方案（其中，应用程序使用*IIdentity*以外的机制来标识用户）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-194">Scenarios include providing XSRF protection to the login page (before the user is authenticated) and custom authentication schemes where the application uses a mechanism other than *IIdentity* to identify users.</span></span>

<span data-ttu-id="b6f68-195">若要支持这些方案，请记住，通过安全令牌（即，128位随机生成的不透明标识符）来联接会话和字段令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-195">To support these scenarios, recall that the session and field tokens are joined by a security token, which is a 128-bit randomly-generated opaque identifier.</span></span> <span data-ttu-id="b6f68-196">此安全令牌用于在用户导航站点时跟踪单个用户的会话，因此它有效地充当了匿名标识符的用途。</span><span class="sxs-lookup"><span data-stu-id="b6f68-196">This security token is used to track an individual user's session as she navigates the site, so it effectively serves the purpose of an anonymous identifier.</span></span> <span data-ttu-id="b6f68-197">空字符串用于替代上述生成和验证例程的用户名。</span><span class="sxs-lookup"><span data-stu-id="b6f68-197">An empty string is used in place of the username for the generation and validation routines described above.</span></span>

<a id="_WIF_ACS"></a>

### <a name="wif--acs--claims-based-authentication"></a><span data-ttu-id="b6f68-198">WIF/ACS/基于声明的身份验证</span><span class="sxs-lookup"><span data-stu-id="b6f68-198">WIF / ACS / claims-based authentication</span></span>

<span data-ttu-id="b6f68-199">通常，内置于 .NET Framework 中的*IIdentity*类具有*IIdentity.Name*足够的属性，用于唯一标识特定应用程序内的特定用户。</span><span class="sxs-lookup"><span data-stu-id="b6f68-199">Normally, the *IIdentity* classes built in to the .NET Framework have the property that *IIdentity.Name* is sufficient to uniquely identify a particular user within a particular application.</span></span> <span data-ttu-id="b6f68-200">例如， *FormsIdentity.Name*返回存储在成员资格数据库中的用户名（这对于所有应用程序都是唯一的，具体取决于该数据库）， *WindowsIdentity.Name*将返回用户的域限定标识，依此类推。</span><span class="sxs-lookup"><span data-stu-id="b6f68-200">For example, *FormsIdentity.Name* returns the username stored in the membership database (which is unique for all applications depending on that database), *WindowsIdentity.Name* returns the domain-qualified identity of the user, and so on.</span></span> <span data-ttu-id="b6f68-201">这些系统不仅提供身份验证;它们还会将用户*标识*到应用程序。</span><span class="sxs-lookup"><span data-stu-id="b6f68-201">These systems provide not only authentication; they also *identify* users to an application.</span></span>

<span data-ttu-id="b6f68-202">另一方面，基于声明的身份验证不一定需要标识特定用户。</span><span class="sxs-lookup"><span data-stu-id="b6f68-202">Claims-based authentication, on the other hand, does not necessarily require identifying a particular user.</span></span> <span data-ttu-id="b6f68-203">相反， *ClaimsPrincipal*和*ClaimsIdentity*类型与*声明*实例集相关联，其中单个声明可能为 "为 18 + 岁以上，或对任何其他内容是管理员"。</span><span class="sxs-lookup"><span data-stu-id="b6f68-203">Instead, the *ClaimsPrincipal* and *ClaimsIdentity* types are associated with a set of *Claim* instances, where the individual claims might be "is 18+ years of age" or "is an administrator" to anything else.</span></span> <span data-ttu-id="b6f68-204">由于用户不必进行标识，因此运行时无法将*ClaimsIdentity.Name*属性用作此特定用户的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="b6f68-204">Since the user hasn't necessarily been identified, the runtime cannot use the *ClaimsIdentity.Name* property as a unique identifier for this particular user.</span></span> <span data-ttu-id="b6f68-205">此团队已经了解了真实的示例，其中*ClaimsIdentity.Name*返回*null*，返回友好（显示）名称，或者返回一个不适合用作用户的唯一标识符的字符串。</span><span class="sxs-lookup"><span data-stu-id="b6f68-205">The team has seen real-world examples where *ClaimsIdentity.Name* returns *null*, returns a friendly (display) name, or otherwise returns a string that isn't appropriate for use as a unique identifier for the user.</span></span>

<span data-ttu-id="b6f68-206">使用基于声明的身份验证的许多部署将特别使用[Azure 访问控制服务](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx)（ACS）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-206">Many of deployments which use claims-based authentication are using [Azure Access Control Service](https://msdn.microsoft.com/library/windowsazure/gg429786.aspx) (ACS) in particular.</span></span> <span data-ttu-id="b6f68-207">ACS 允许开发人员配置单个*标识提供者*（如 ADFS、Microsoft 帐户提供程序、OpenID 提供程序（例如 yahoo！等）），标识提供程序将返回*名称标识符*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-207">ACS allows the developer to configure individual *identity providers* (such as ADFS, the Microsoft Account provider, OpenID providers like Yahoo!, etc.), and the identity providers return *name identifiers*.</span></span> <span data-ttu-id="b6f68-208">这些名称标识符可以包含个人身份信息（PII）（如电子邮件地址），也可以匿名，如专用个人标识符（PPID）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-208">These name identifiers may contain Personally Identifiable Information (PII) like an email address, or they could be anonymized like a Private Personal Identifier (PPID).</span></span> <span data-ttu-id="b6f68-209">无论如何，元组（标识提供者、名称标识符）在浏览站点时都能充分充当特定用户的相应跟踪令牌，因此，ASP.NET Web Stack 运行时可以使用元组来代替用户名，正在验证 XSRF 字段标记。</span><span class="sxs-lookup"><span data-stu-id="b6f68-209">Regardless, the tuple (identity provider, name identifier) sufficiently serves as an appropriate tracking token for a particular user while she is browsing the site, so the ASP.NET Web Stack Runtime can use the tuple in place of the username when generating and validating anti-XSRF field tokens.</span></span> <span data-ttu-id="b6f68-210">标识提供程序和名称标识符的特定 Uri 为：</span><span class="sxs-lookup"><span data-stu-id="b6f68-210">The particular URIs for the identity provider and the name identifier are :</span></span>

- `https://schemas.microsoft.com/accesscontrolservice/2010/07/claims/identityprovider`
- `http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier`

<span data-ttu-id="b6f68-211">（有关详细信息，请参阅此[ACS 文档页](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx)。）</span><span class="sxs-lookup"><span data-stu-id="b6f68-211">(see this [ACS doc page](https://msdn.microsoft.com/library/windowsazure/gg185971.aspx) for more info.)</span></span>

<span data-ttu-id="b6f68-212">生成或验证令牌时，ASP.NET Web Stack 运行时将在运行时尝试绑定到类型：</span><span class="sxs-lookup"><span data-stu-id="b6f68-212">When generating or validating a token, the ASP.NET Web Stack Runtime will at runtime try binding to the types:</span></span>

- <span data-ttu-id="b6f68-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` （适用于 WIF SDK）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-213">`Microsoft.IdentityModel.Claims.IClaimsIdentity, Microsoft.IdentityModel, Version=3.5.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35` (For the WIF SDK.)</span></span>
- <span data-ttu-id="b6f68-214">`System.Security.Claims.ClaimsIdentity` （适用于 .NET 4.5）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-214">`System.Security.Claims.ClaimsIdentity` (For .NET 4.5).</span></span>

<span data-ttu-id="b6f68-215">如果这些类型存在，并且当前用户的*IIIIdentity*实现或子类其中一种类型，则在生成和验证令牌时，反 XSRF 设施将使用（标识提供者、名称标识符）元组来代替用户名。</span><span class="sxs-lookup"><span data-stu-id="b6f68-215">If these types exist, and if the current user's *IIIIdentity* implements or subclasses one of these types, the anti-XSRF facility will use the (identity provider, name identifier) tuple in place of the username when generating and validating the tokens.</span></span> <span data-ttu-id="b6f68-216">如果不存在这样的元组，则该请求将失败，并显示一条错误，指出开发人员如何配置反 XSRF 系统以了解所使用的特定于声明的特定身份验证机制。</span><span class="sxs-lookup"><span data-stu-id="b6f68-216">If no such tuple is present, the request will fail with an error describing to the developer how to configure the anti-XSRF system to understand the particular claims-based authentication mechanism in use.</span></span> <span data-ttu-id="b6f68-217">有关详细信息，请参阅 **[配置和扩展性](#_Configuration_and_extensibility)** 部分。</span><span class="sxs-lookup"><span data-stu-id="b6f68-217">See the **[Configuration and extensibility](#_Configuration_and_extensibility)** section for more information.</span></span>

### <a name="oauth--openid-authentication"></a><span data-ttu-id="b6f68-218">OAuth/OpenID 身份验证</span><span class="sxs-lookup"><span data-stu-id="b6f68-218">OAuth / OpenID authentication</span></span>

<span data-ttu-id="b6f68-219">最后，XSRF 工具对使用 OAuth 或 OpenID 身份验证的应用程序有特殊支持。</span><span class="sxs-lookup"><span data-stu-id="b6f68-219">Finally, the anti-XSRF facility has special support for applications which use OAuth or OpenID authentication.</span></span> <span data-ttu-id="b6f68-220">此支持基于试探法：如果当前*IIdentity.Name*以 http://或 https://开头，则将使用序号比较器而不是默认的 stringcomparison.ordinalignorecase 比较器来完成用户名比较。</span><span class="sxs-lookup"><span data-stu-id="b6f68-220">This support is heuristic-based: if the current *IIdentity.Name* begins with http:// or https://, then username comparisons will be done using an Ordinal comparer rather than the default OrdinalIgnoreCase comparer.</span></span>

<a id="_Configuration_and_extensibility"></a>

## <a name="configuration-and-extensibility"></a><span data-ttu-id="b6f68-221">配置和扩展性</span><span class="sxs-lookup"><span data-stu-id="b6f68-221">Configuration and extensibility</span></span>

<span data-ttu-id="b6f68-222">有时，开发人员可能希望更严格地控制反 XSRF 生成和验证行为。</span><span class="sxs-lookup"><span data-stu-id="b6f68-222">Occasionally, developers may want tighter control over the anti-XSRF generation and validation behaviors.</span></span> <span data-ttu-id="b6f68-223">例如，可能不需要 MVC 和 Web Pages 助手的默认行为自动将 HTTP cookie 添加到响应中，开发人员可能希望将令牌保存在其他位置。</span><span class="sxs-lookup"><span data-stu-id="b6f68-223">For example, perhaps the MVC and Web Pages helpers' default behavior of automatically adding HTTP cookies to the response is undesirable, and the developer may wish to persist the tokens elsewhere.</span></span> <span data-ttu-id="b6f68-224">有两个 Api 可帮助解决此操作：</span><span class="sxs-lookup"><span data-stu-id="b6f68-224">There exist two APIs to assist with this:</span></span>

`AntiForgery.GetTokens(string oldCookieToken, out string newCookieToken, out string formToken);`  
`AntiForgery.Validate(string cookieToken, string formToken);`

<span data-ttu-id="b6f68-225">*GetTokens*方法将现有的 XSRF 请求验证会话令牌作为输入，并生成新的 XSRF 请求验证会话令牌和字段令牌作为输出。</span><span class="sxs-lookup"><span data-stu-id="b6f68-225">The *GetTokens* method takes as input an existing XSRF request verification session token (which may be null) and produces as output a new XSRF request verification session token and field token.</span></span> <span data-ttu-id="b6f68-226">标记只是不透明的字符串，无修饰;实例的*formToken*值将不会 &lt;输入&gt; 标记中进行包装。</span><span class="sxs-lookup"><span data-stu-id="b6f68-226">The tokens are simply opaque strings with no decoration; the *formToken* value will for instance not be wrapped in an &lt;input&gt; tag.</span></span> <span data-ttu-id="b6f68-227">*NewCookieToken*值可以为 null;如果出现这种情况，则*oldCookieToken*值仍然有效，无需设置新的响应 cookie。</span><span class="sxs-lookup"><span data-stu-id="b6f68-227">The *newCookieToken* value may be null; if this occurs, then the *oldCookieToken* value is still valid and no new response cookie need be set.</span></span> <span data-ttu-id="b6f68-228">*GetTokens*的调用方负责持久保存任何必需的响应 cookie 或生成任何所需的标记;*GetTokens*方法本身不会将响应更改为副作用。</span><span class="sxs-lookup"><span data-stu-id="b6f68-228">The caller of *GetTokens* is responsible for persisting any necessary response cookies or generating any necessary markup; the *GetTokens* method itself will not alter the response as a side effect.</span></span> <span data-ttu-id="b6f68-229">*Validate*方法获取传入会话和字段令牌，并对其运行上述验证逻辑。</span><span class="sxs-lookup"><span data-stu-id="b6f68-229">The *Validate* method takes the incoming session and field tokens and runs the aforementioned validation logic over them.</span></span>

### <a name="antiforgeryconfig"></a><span data-ttu-id="b6f68-230">AntiForgeryConfig</span><span class="sxs-lookup"><span data-stu-id="b6f68-230">AntiForgeryConfig</span></span>

<span data-ttu-id="b6f68-231">开发人员可以从应用程序\_开始配置 XSRF 系统。</span><span class="sxs-lookup"><span data-stu-id="b6f68-231">The developer may configure the anti-XSRF system from Application\_Start.</span></span> <span data-ttu-id="b6f68-232">配置是以编程方式进行的。</span><span class="sxs-lookup"><span data-stu-id="b6f68-232">Configuration is programmatic.</span></span> <span data-ttu-id="b6f68-233">下面描述了静态*AntiForgeryConfig*类型的属性。</span><span class="sxs-lookup"><span data-stu-id="b6f68-233">The properties of the static *AntiForgeryConfig* type are described below.</span></span> <span data-ttu-id="b6f68-234">大多数使用声明的用户都要设置 UniqueClaimTypeIdentifier 属性。</span><span class="sxs-lookup"><span data-stu-id="b6f68-234">Most users using claims will want to set the UniqueClaimTypeIdentifier property.</span></span>

| <span data-ttu-id="b6f68-235">**Property**</span><span class="sxs-lookup"><span data-stu-id="b6f68-235">**Property**</span></span> | <span data-ttu-id="b6f68-236">**描述**</span><span class="sxs-lookup"><span data-stu-id="b6f68-236">**Description**</span></span> |
| --- | --- |
| <span data-ttu-id="b6f68-237">**AdditionalDataProvider**</span><span class="sxs-lookup"><span data-stu-id="b6f68-237">**AdditionalDataProvider**</span></span> | <span data-ttu-id="b6f68-238">在令牌生成过程中提供附加数据并在令牌验证期间使用其他数据的[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) 。</span><span class="sxs-lookup"><span data-stu-id="b6f68-238">An [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) that provides additional data during token generation and consumes additional data during token validation.</span></span> <span data-ttu-id="b6f68-239">默认值为*null*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-239">The default value is *null*.</span></span> <span data-ttu-id="b6f68-240">有关详细信息，请参阅[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)部分。</span><span class="sxs-lookup"><span data-stu-id="b6f68-240">For more information, see the [IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx) section.</span></span> |
| <span data-ttu-id="b6f68-241">**CookieName**</span><span class="sxs-lookup"><span data-stu-id="b6f68-241">**CookieName**</span></span> | <span data-ttu-id="b6f68-242">一个字符串，它提供用于存储 XSRF 会话令牌的 HTTP cookie 的名称。</span><span class="sxs-lookup"><span data-stu-id="b6f68-242">A string that provides the name of the HTTP cookie that is used to store the anti-XSRF session token.</span></span> <span data-ttu-id="b6f68-243">如果未设置此值，将根据应用程序的已部署虚拟路径自动生成名称。</span><span class="sxs-lookup"><span data-stu-id="b6f68-243">If this value is not set, a name will be automatically generated based on the application's deployed virtual path.</span></span> <span data-ttu-id="b6f68-244">默认值为*null*。</span><span class="sxs-lookup"><span data-stu-id="b6f68-244">The default value is *null*.</span></span> |
| <span data-ttu-id="b6f68-245">**RequireSsl**</span><span class="sxs-lookup"><span data-stu-id="b6f68-245">**RequireSsl**</span></span> | <span data-ttu-id="b6f68-246">一个布尔值，指示是否需要在受 SSL 保护的通道上提交 XSRF 令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-246">A Boolean that dictates whether the anti-XSRF tokens are required to be submitted over an SSL-secured channel.</span></span> <span data-ttu-id="b6f68-247">如果此值为*true*，则自动生成的任何 cookie 都将设置 "安全" 标志，并在从未通过 SSL 提交的请求内调用时，将引发 XSRF api。</span><span class="sxs-lookup"><span data-stu-id="b6f68-247">If this value is *true*, any automatically-generated cookies will have the "secure" flag set, and the anti-XSRF APIs will throw if called from within a request that is not submitted via SSL.</span></span> <span data-ttu-id="b6f68-248">默认值为“false”。</span><span class="sxs-lookup"><span data-stu-id="b6f68-248">The default value is *false*.</span></span> |
| <span data-ttu-id="b6f68-249">**SuppressIdentityHeuristicChecks**</span><span class="sxs-lookup"><span data-stu-id="b6f68-249">**SuppressIdentityHeuristicChecks**</span></span> | <span data-ttu-id="b6f68-250">一个布尔值，指示 XSRF 系统是否应停用其对基于声明的标识的支持。</span><span class="sxs-lookup"><span data-stu-id="b6f68-250">A Boolean that dictates whether the anti-XSRF system should deactivate its support for claims-based identities.</span></span> <span data-ttu-id="b6f68-251">如果此值为*true*，则系统将假设*IIdentity.Name*适用于用作唯一的每用户标识符，并且不会尝试如 WIF/ACS/中所述的特殊情况*IClaimsIdentity*或*ClClaimsIdentity* [基于声明的身份验证](#_WIF_ACS)部分。</span><span class="sxs-lookup"><span data-stu-id="b6f68-251">If this value is *true*, the system will assume that *IIdentity.Name* is appropriate for use as a unique per-user identifier and will not try to special-case *IClaimsIdentity* or *ClClaimsIdentity* as described in the [WIF / ACS / claims-based authentication](#_WIF_ACS) section.</span></span> <span data-ttu-id="b6f68-252">默认值为 `false`。</span><span class="sxs-lookup"><span data-stu-id="b6f68-252">The default value is `false`.</span></span> |
| <span data-ttu-id="b6f68-253">**UniqueClaimTypeIdentifier**</span><span class="sxs-lookup"><span data-stu-id="b6f68-253">**UniqueClaimTypeIdentifier**</span></span> | <span data-ttu-id="b6f68-254">一个字符串，指示哪种声明类型适用于每个用户的唯一标识符。</span><span class="sxs-lookup"><span data-stu-id="b6f68-254">A string that indicates which claim type is appropriate for use as a unique per-user identifier.</span></span> <span data-ttu-id="b6f68-255">如果设置了此值并且当前*IIdentity*是基于声明的，则系统将尝试提取*UniqueClaimTypeIdentifier*指定的类型的声明，并将在以下情况下使用相应的值来代替用户的用户名。正在生成字段标记。</span><span class="sxs-lookup"><span data-stu-id="b6f68-255">If this value is set and the current *IIdentity* is claims-based, the system will attempt to extract a claim of the type specified by *UniqueClaimTypeIdentifier*, and the corresponding value will be used in place of the user's username when generating the field token.</span></span> <span data-ttu-id="b6f68-256">如果找不到声明类型，则系统将无法请求。</span><span class="sxs-lookup"><span data-stu-id="b6f68-256">If the claim type is not found, the system will fail the request.</span></span> <span data-ttu-id="b6f68-257">默认值为*null*，指示系统应使用（标识提供者、名称标识符）元组作为前面介绍的替代用户的用户名。</span><span class="sxs-lookup"><span data-stu-id="b6f68-257">The default value is *null*, which indicates that the system should use the (identity provider, name identifier) tuple as previously described in place of the user's username.</span></span> |

<a id="_IAntiForgeryAdditionalDataProvider"></a>

### <a name="iantiforgeryadditionaldataprovider"></a><span data-ttu-id="b6f68-258">IAntiForgeryAdditionalDataProvider</span><span class="sxs-lookup"><span data-stu-id="b6f68-258">IAntiForgeryAdditionalDataProvider</span></span>

<span data-ttu-id="b6f68-259">*[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* 类型允许开发人员通过往返每个标记中的其他数据来扩展反 XSRF 系统的行为。</span><span class="sxs-lookup"><span data-stu-id="b6f68-259">The *[IAntiForgeryAdditionalDataProvider](https://msdn.microsoft.com/library/system.web.helpers.iantiforgeryadditionaldataprovider(v=vs.111).aspx)* type allows developers to extend the behavior of the anti-XSRF system by round-tripping additional data in each token.</span></span> <span data-ttu-id="b6f68-260">每次生成字段标记时都会调用*GetAdditionalData*方法，并且返回值嵌入到生成的标记中。</span><span class="sxs-lookup"><span data-stu-id="b6f68-260">The *GetAdditionalData* method is called each time a field token is generated, and the return value is embedded within the generated token.</span></span> <span data-ttu-id="b6f68-261">实施者可能会从该方法返回一个时间戳、nonce 或其他任何值。</span><span class="sxs-lookup"><span data-stu-id="b6f68-261">An implementer could return a timestamp, a nonce, or any other value she wishes from this method.</span></span>

<span data-ttu-id="b6f68-262">同样，每次验证字段令牌时，都会调用*ValidateAdditionalData*方法，并且在令牌中嵌入的 "附加数据" 字符串将传递给方法。</span><span class="sxs-lookup"><span data-stu-id="b6f68-262">Similarly, the *ValidateAdditionalData* method is called each time a field token is validated, and the "additional data" string that was embedded within the token is passed to the method.</span></span> <span data-ttu-id="b6f68-263">验证例程可能会实现超时（通过检查当前时间和创建令牌时存储的时间）、nonce 检查例程或任何其他所需的逻辑。</span><span class="sxs-lookup"><span data-stu-id="b6f68-263">The validation routine could implement a timeout (by checking the current time against the time that was stored when the token was created), a nonce checking routine, or any other desired logic.</span></span>

## <a name="design-decisions-and-security-considerations"></a><span data-ttu-id="b6f68-264">设计决策和安全注意事项</span><span class="sxs-lookup"><span data-stu-id="b6f68-264">Design decisions and security considerations</span></span>

<span data-ttu-id="b6f68-265">在技术上，仅在尝试防止匿名/未经身份验证的用户防御 XSRF 攻击时，才需要在技术上链接会话和字段令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-265">The security token that links the session and field tokens is technically only necessary when trying to protect anonymous / unauthenticated users against XSRF attacks.</span></span> <span data-ttu-id="b6f68-266">对用户进行身份验证时，身份验证令牌本身（以 cookie 的形式提交）可以用作同步令牌对的一半。</span><span class="sxs-lookup"><span data-stu-id="b6f68-266">When the user is authenticated, the authentication token itself (presumably submitted in the form of a cookie) could be used as one half of a synchronizer token pair.</span></span> <span data-ttu-id="b6f68-267">但是，可以使用有效的方案来保护通过未经身份验证的用户访问的登录页，并通过始终生成和验证安全令牌（即使对于经过身份验证的用户）使 XSRF 逻辑更简单。</span><span class="sxs-lookup"><span data-stu-id="b6f68-267">However, there are valid scenarios for protecting login pages hit by unauthenticated users, and the anti-XSRF logic was made simpler by always generating and validating the security token, even for authenticated users.</span></span> <span data-ttu-id="b6f68-268">如果某个字段令牌被攻击者泄露，还会提供一些额外的保护措施，因为设置或猜测会话令牌会成为攻击者面临的另一个障碍。</span><span class="sxs-lookup"><span data-stu-id="b6f68-268">It also does provide some additional protection in the event that a field token is ever compromised by an attacker, as setting or guessing the session token would be another hurdle for the attacker to overcome.</span></span>

<span data-ttu-id="b6f68-269">在单个域中托管多个应用程序时，开发人员应小心。</span><span class="sxs-lookup"><span data-stu-id="b6f68-269">Developers should use caution when multiple applications are hosted in a single domain.</span></span> <span data-ttu-id="b6f68-270">例如，即使*example1.cloudapp.net*和*example2.cloudapp.net*是不同的主机， *\*cloudapp.net*域下的所有主机之间也存在隐式信任关系。</span><span class="sxs-lookup"><span data-stu-id="b6f68-270">For example, even though *example1.cloudapp.net* and *example2.cloudapp.net* are different hosts, there is an implicit trust relationship between all hosts under the *\*.cloudapp.net* domain.</span></span> <span data-ttu-id="b6f68-271">这种隐式信任关系[允许可能不受信任的主机影响彼此的 cookie](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) （控制 AJAX 请求的相同源策略并不一定适用于 HTTP cookie）。</span><span class="sxs-lookup"><span data-stu-id="b6f68-271">This implicit trust relationship [allows potentially untrusted hosts to affect each other's cookies](http://stackoverflow.com/questions/9636857/how-can-asp-net-or-asp-net-mvc-be-protected-from-related-domain-cookie-attacks) (the same-origin policies that govern AJAX requests do not necessarily apply to HTTP cookies).</span></span> <span data-ttu-id="b6f68-272">ASP.NET Web Stack 运行时提供一些缓解措施，因为用户名嵌入到字段令牌中，因此即使恶意子域能够覆盖会话令牌，也不能为用户生成有效的字段令牌。</span><span class="sxs-lookup"><span data-stu-id="b6f68-272">The ASP.NET Web Stack Runtime provides some mitigation in that the username is embedded into the field token, so even if a malicious subdomain is able to overwrite a session token it will be unable to generate a valid field token for the user.</span></span> <span data-ttu-id="b6f68-273">但是，如果在此类环境中托管，则内置的 XSRF 例程仍无法防御会话劫持或登录 XSRF。</span><span class="sxs-lookup"><span data-stu-id="b6f68-273">However, when hosted in such an environment the built-in anti-XSRF routines still cannot defend against session hijacking or login XSRF.</span></span>

<span data-ttu-id="b6f68-274">XSRF 例程当前不防御[点击劫持](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="b6f68-274">The anti-XSRF routines currently do not defend against [clickjacking](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="b6f68-275">希望针对点击劫持进行保护的应用程序可以通过发送 X 框架选项： SAMEORIGIN 标头和每个响应来轻松实现此目的。</span><span class="sxs-lookup"><span data-stu-id="b6f68-275">Applications that wish to defend themselves against clickjacking may easily do so by sending an X-Frame-Options: SAMEORIGIN header with each response.</span></span> <span data-ttu-id="b6f68-276">所有最新的浏览器都支持此标头。</span><span class="sxs-lookup"><span data-stu-id="b6f68-276">This header is supported by all recent browsers.</span></span> <span data-ttu-id="b6f68-277">有关详细信息，请参阅[IE 博客](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx)、 [SDL 博客](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx)和[OWASP](https://www.owasp.org/index.php/Clickjacking)。</span><span class="sxs-lookup"><span data-stu-id="b6f68-277">For more information, see the [IE blog](https://blogs.msdn.com/b/ieinternals/archive/2010/03/30/combating-clickjacking-with-x-frame-options.aspx), the [SDL blog](https://blogs.msdn.com/b/sdl/archive/2009/02/05/clickjacking-defense-in-ie8.aspx), and [OWASP](https://www.owasp.org/index.php/Clickjacking).</span></span> <span data-ttu-id="b6f68-278">ASP.NET Web Stack 运行时可能会在将来的版本中使 MVC 和 Web Pages XSRF 帮助器自动设置此标头，以便自动保护应用程序免受这种攻击。</span><span class="sxs-lookup"><span data-stu-id="b6f68-278">The ASP.NET Web Stack Runtime may in some future release make the MVC and Web Pages anti-XSRF helpers automatically set this header so that applications are automatically protected against this attack.</span></span>

<span data-ttu-id="b6f68-279">Web 开发人员应继续确保其网站不会受到 XSS 攻击。</span><span class="sxs-lookup"><span data-stu-id="b6f68-279">Web developers should continue to ensure that their site is not vulnerable to XSS attacks.</span></span> <span data-ttu-id="b6f68-280">XSS 攻击非常强大，成功利用漏洞还会破坏 ASP.NET Web Stack 运行时防御 XSRF 攻击。</span><span class="sxs-lookup"><span data-stu-id="b6f68-280">XSS attacks are very powerful, and a successful exploit would also break the ASP.NET Web Stack Runtime defenses against XSRF attacks.</span></span>

## <a name="acknowledgment"></a><span data-ttu-id="b6f68-281">回执</span><span class="sxs-lookup"><span data-stu-id="b6f68-281">Acknowledgment</span></span>

<span data-ttu-id="b6f68-282">[@LeviBroderick](https://twitter.com/LeviBroderick)，其中大部分 ASP.NET 的安全代码都是此信息。</span><span class="sxs-lookup"><span data-stu-id="b6f68-282">[@LeviBroderick](https://twitter.com/LeviBroderick), who wrote much of the ASP.NET security code the bulk of this information.</span></span>
